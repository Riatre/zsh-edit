#!/bin/zsh
emulate -L zsh
zmodload zsh/complist
zmodload zsh/parameter
zmodload -Fa zsh/terminfo p:terminfo
zmodload -Fa zsh/zleparameter p:widgets

bindkey() {
  emulate -L zsh; setopt $_edit_opts

  local -A opts=()
  zparseopts -D -E -A opts - c n u U

  if [[ -v opts[-c] ]]; then
    zle -N ".$@[-1]" _execute_cmd
    builtin bindkey "$@[1,-2]" ".$@[-1]"

  elif [[ -v opts[-n] ]]; then
    local code="$(print -b - $1)"
    local name=${(k)key[(Re)$code]}

    if [[ -z $name && $code == $'\e['[ABCDFH]* ]]; then
      case $code in
        $'\e[A'* ) name='Up'    ;;
        $'\e[B'* ) name='Down'  ;;
        $'\e[C'* ) name='Right' ;;
        $'\e[D'* ) name='Left'  ;;
        $'\e[F'* ) name='End'   ;;
        $'\e[H'* ) name='Home'  ;;
      esac
      code="${code#$'\e['?}"
      [[ -n "$code" ]] &&
          name+=" + $(bindkey -n $code)"
    fi

    if [[ -z $name ]]; then
      local -a matches=( "${(k@)terminfo[(Re)$code]}" )
      (( $#matches[@] > 1 )) &&
          matches=( "$matches[(r)k*]" )
      name="$matches[1]"
      if [[ -n $name && -v commands[man] ]]; then
        local -a match mbegin mend
        local expl="$(< $(man --path terminfo))"
        expl=${(SM)expl#$'\t'${name}$'\t'??$'\t'T\{$'\n'(#b)(*)$'\n'}
        expl=${${(C)match[1]%%(| function) key}//[ -]/}
        [[ -n $expl ]] &&
            name=$expl
      fi
    fi

    if [[ -z $name ]]; then
      case $code in
        $'\C-@'* )
          name='Control-Space'
          code=${code#$'\C-@'}
          [[ -n "$code" ]] &&
              name+=" + $(bindkey -n $code)"
          ;;
        $'\C-?'* )
          name='Backspace'
          code=${code#$'\C-?'}
          [[ -n "$code" ]] &&
              name+=" + $(bindkey -n $code)"
          ;;
        $'\e'* )
          name="Alt"
          code="${code#$'\e'}"
          [[ -n "$code" ]] &&
              name+="-$(bindkey -n $code)"
          ;;
        [$'\C-A'-$'\C-^']* )
          name="Control-${(SM)${(Mq+)code#[$'\C-A'-$'\C-^']}%[A-^]}"
          code="${code#[$'\C-A'-$'\C-^']}"
          [[ -n "$code" ]] &&
              name+=" + $(bindkey -n $code)"
          ;;
        * )
          name='??'
          ;;
      esac
    fi
    print $name

  elif [[ -v opts[-u] ]]; then
    local -a args=( $@ )
    local -a control=( {$'\0'..$'\C-B'} {$'\C-D'..$'\C-_'} $'\C-?' )
    local -a printable=( {' '..'~'} )
    local -a termkeys=( kbs kich1 kdch1 khome kend kpp knp kcuu1 kcub1 kcud1 kcuf1 )
    termkeys=( ${(vn)terminfo[(I)(${(~j:|:)termkeys})]} )
    local -a fkeys=( ${(vn)terminfo[(I)kf<1-20>]} )
    local -a val=()
    local key; for key in $printable $control $'\e'$^printable $'\e'$^control \
        $termkeys $'\e'$^termkeys $fkeys $'\e'$^fkeys; do
      [[ $(builtin bindkey $args[@] - $key)$(builtin bindkey $args[@] -p - $key)
              == *'undefined-key' ]] &&
          val+=( ${${${${${(q+)key}//'\C-'/^}//'\\'/\\}#(|\$)[\']}%[\']} )
    done
    (( $#val )) &&
        print -cr - ${(q-)val}

  elif [[ -v opts[-U] ]]; then
    local -a bindings dup_bindings=() all_bindings=( ${(f)"$(bindkey $@)"} )
    local w; for w in "${(@ko)widgets}"; do
      bindings=( ${(M)all_bindings:#* $w}  )
      (( $#bindings > 1 )) &&
          dup_bindings+=( $w "\t${(j:\t:)bindings[@]% $w}" )
    done
    print -aC2 $dup_bindings[@]

  else
    builtin bindkey "$@"
  fi
}

bindkey "$@"
